export async function onRequest(context) {
  const { request, env, next } = context;
  const url = new URL(request.url);

  // Fetch the original response from the underlying asset or the next function in the chain
  const originalResponse = await next();

  // Only proceed if the response is HTML
  if (!originalResponse.headers.get("content-type")?.includes("text/html")) {
    return originalResponse; // Not HTML, so pass through untouched
  }

  // Check for dynamic OG parameters
  const bgParam = url.searchParams.get('bg');
  const fgParam = url.searchParams.get('fg');
  const isGetRequest = request.method === 'GET';

  if (isGetRequest && bgParam && fgParam) {
    // Dynamic OG tags needed
    const encodedBg = encodeURIComponent(bgParam);
    const encodedFg = encodeURIComponent(fgParam);
    const ogImageWorkerUrl = 'https://randoma11y-feed.adam-f8f.workers.dev';
    const ogImageUrl = `${ogImageWorkerUrl}/og-image.svg?bg=${encodedBg}&fg=${encodedFg}`;
    const pageUrl = url.toString();
    const dynamicTitle = `RandomA11y: ${bgParam} / ${fgParam}`;
    const dynamicDescription = `Explore this accessible color combination: ${bgParam} background with ${fgParam} text. Generated by RandomA11y.`;

    const tagsToInject = [
      { property: 'og:title', content: dynamicTitle },
      { property: 'og:description', content: dynamicDescription },
      { property: 'og:url', content: pageUrl },
      { property: 'og:image', content: ogImageUrl },
      { property: 'og:image:width', content: '1200' },
      { property: 'og:image:height', content: '630' },
      { property: 'og:type', content: 'website' },
      { property: 'twitter:card', content: 'summary_large_image' },
      { property: 'twitter:title', content: dynamicTitle },
      { property: 'twitter:description', content: dynamicDescription },
      { property: 'twitter:image', content: ogImageUrl },
    ];

    class MetaTagManager {
      constructor(tags) {
        this.tagsToSet = tags;
        // Create a set of property values we intend to set for quick lookup
        this.propertiesToManage = new Set();
        this.tagsToSet.forEach(tag => this.propertiesToManage.add(tag.property));
      }

      element(element) {
        const property = element.getAttribute('property'); // For og:*
        const name = element.getAttribute('name');       // For twitter:*

        // Check if the current element's property or name is one we intend to manage
        if ((property && this.propertiesToManage.has(property)) || 
            (name && this.propertiesToManage.has(name))) {
          element.remove(); // Remove it to prevent duplicates
        }
      }

      end(end) {
        let tagsHtml = '<!-- Dynamic OG Tags Injected by Pages Function (v2) -->\n';
        this.tagsToSet.forEach(tag => {
          const attributeName = tag.property.startsWith('twitter:') ? 'name' : 'property';
          const escapedContent = tag.content.replace(/"/g, '&quot;').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
          tagsHtml += `<meta ${attributeName}="${tag.property}" content="${escapedContent}" />\n`;
        });
        end.append(tagsHtml, { html: true });
      }
    }
    
    return new HTMLRewriter()
      .on('head', new MetaTagManager(tagsToInject))
      .transform(originalResponse);

  } else {
    // No dynamic parameters, or not a GET request for dynamic content.
    // Serve the original HTML with its static tags.
    // Optionally, add a comment to confirm this path was taken.
    // class StaticPathConfirmComment {
    //     element(el) { el.append("<!-- SERVING STATIC: No dynamic params or not GET for dynamic -->", {html: true}); }
    // }
    // return new HTMLRewriter().on("head", new StaticPathConfirmComment()).transform(originalResponse);
    return originalResponse; // Simpler: just return as is.
  }

  // Fallback, should not be reached if the logic above is sound.
  // If it is, it means neither dynamic nor static path was decisively chosen.
  class FallbackComment {
      element(el) { el.append("<!-- UNEXPECTED FALLTHROUGH -->", {html: true}); }
  }
  return new HTMLRewriter().on("head", new FallbackComment()).transform(originalResponse);
} 