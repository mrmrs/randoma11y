export async function onRequest(context) {
  const { request, env, next } = context;
  const url = new URL(request.url);

  // Fetch the original page asset first. This is important.
  let response = await next();

  // --- BEGIN TEMPORARY DEBUGGING ---
  // Create a simple HTMLRewriter to add a comment, to see if the middleware is running at all.
  // This will run on ALL HTML responses if the middleware is active.
  if (response.headers.get("content-type")?.includes("text/html")) {
    class HeadDebugInjector {
      element(element) {
        // What the function sees:
        const method = request.method;
        const searchParams = url.searchParams.toString();
        const contentType = response.headers.get("content-type") || 'null';

        let debugHtml = "<!-- FUNCTIONS/_MIDDLEWARE.JS WAS HERE -->\n";
        debugHtml += `<!-- METHOD: ${method} -->\n`;
        debugHtml += `<!-- SEARCH PARAMS: ${searchParams} -->\n`;
        debugHtml += `<!-- CONTENT-TYPE: ${contentType} -->\n`;
        element.append(debugHtml, { html: true });
      }
    }
    response = new HTMLRewriter().on("head", new HeadDebugInjector()).transform(response);
  }
  // --- END TEMPORARY DEBUGGING ---


  // Only act on GET requests for the dynamic OG tag logic
  if (request.method !== 'GET') {
    return response; // Return the (potentially comment-injected) response
  }

  const bgParam = url.searchParams.get('bg');
  const fgParam = url.searchParams.get('fg');

  // Only rewrite for dynamic OG tags if it's an HTML response AND we have bg/fg params
  // Note: 'response' here is already the one potentially modified by the debug comment injector
  if (bgParam && fgParam && response.headers.get("content-type")?.includes("text/html")) {
    const encodedBg = encodeURIComponent(bgParam);
    const encodedFg = encodeURIComponent(fgParam);

    const ogImageWorkerUrl = 'https://randoma11y-feed.adam-f8f.workers.dev'; 
    const ogImageUrl = `${ogImageWorkerUrl}/og-image.svg?bg=${encodedBg}&fg=${encodedFg}`;
    
    const pageUrl = url.toString(); 
    const title = `RandomA11y: ${bgParam} / ${fgParam}`;
    const description = `Explore this accessible color combination: ${bgParam} background with ${fgParam} text. Generated by RandomA11y.`;

    class MetaTagInjector {
      constructor(tagsToSet) {
        this.tagsToSet = tagsToSet;
      }

      element(element) {
        const property = element.getAttribute('property');
        if (property && (property.startsWith('og:') || property.startsWith('twitter:'))) {
          if (this.tagsToSet.find(t => t.property === property)) {
            element.remove(); 
          }
        }
        // if (element.tagName === 'title') { 
        //   element.setInnerContent(title);
        // }
      }

      end(end) {
        let tagsHtml = '<!-- DYNAMIC OG BLOCK EXECUTED -->\n';
        this.tagsToSet.forEach(tag => {
          const escapedContent = tag.content.replace(/"/g, '&quot;').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
          tagsHtml += `<meta property="${tag.property}" content="${escapedContent}" />\n`;
        });
        if (this.tagsToSet.some(tag => tag.property === 'og:image')) {
            tagsHtml += `<meta property="og:image:width" content="1200" />\n`;
            tagsHtml += `<meta property="og:image:height" content="630" />\n`;
        }
        end.append(tagsHtml, { html: true });
      }
    }

    const tags = [
      { property: 'og:title', content: title },
      { property: 'og:description', content: description },
      { property: 'og:url', content: pageUrl },
      { property: 'og:image', content: ogImageUrl },
      { property: 'og:type', content: 'website' },
      { property: 'twitter:card', content: 'summary_large_image' },
      { property: 'twitter:title', content: title },
      { property: 'twitter:description', content: description },
      { property: 'twitter:image', content: ogImageUrl },
    ];

    // Important: transform the 'response' we got after the potential debug comment injection
    return new HTMLRewriter()
      .on('head', new MetaTagInjector(tags))
      .transform(response);
  }

  return response; 
} 