export async function onRequest(context) {
  const { request, env, next } = context;
  const url = new URL(request.url);

  // Only act on GET requests
  if (request.method !== 'GET') {
    return next();
  }

  const bgParam = url.searchParams.get('bg');
  const fgParam = url.searchParams.get('fg');

  // Fetch the original page asset first. We need its content type.
  const response = await next();

  // Only rewrite if it's an HTML response and we have bg/fg params for dynamic OG tags
  if (bgParam && fgParam && response.headers.get("content-type")?.includes("text/html")) {
    const encodedBg = encodeURIComponent(bgParam);
    const encodedFg = encodeURIComponent(fgParam);

    // IMPORTANT: This is the URL of your *standalone worker* that generates the OG images.
    const ogImageWorkerUrl = 'https://randoma11y-feed.adam-f8f.workers.dev'; 
    const ogImageUrl = `${ogImageWorkerUrl}/og-image.svg?bg=${encodedBg}&fg=${encodedFg}`;
    
    const pageUrl = url.toString(); 
    const title = `RandomA11y: ${bgParam} / ${fgParam}`;
    const description = `Explore this accessible color combination: ${bgParam} background with ${fgParam} text. Generated by RandomA11y.`;

    class MetaTagInjector {
      constructor(tagsToSet) {
        this.tagsToSet = tagsToSet;
      }

      element(element) {
        const property = element.getAttribute('property');
        if (property && (property.startsWith('og:') || property.startsWith('twitter:'))) {
          if (this.tagsToSet.find(t => t.property === property)) {
            element.remove(); // Remove existing tag if we are providing a new one
          }
        }
        // if (element.tagName === 'title') { // Optionally replace main title
        //   element.setInnerContent(title);
        // }
      }

      end(end) {
        let tagsHtml = '';
        this.tagsToSet.forEach(tag => {
          const escapedContent = tag.content.replace(/"/g, '&quot;').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
          tagsHtml += `<meta property="${tag.property}" content="${escapedContent}" />\n`;
        });
        if (this.tagsToSet.some(tag => tag.property === 'og:image')) {
            tagsHtml += `<meta property="og:image:width" content="1200" />\n`;
            tagsHtml += `<meta property="og:image:height" content="630" />\n`;
        }
        end.append(tagsHtml, { html: true });
      }
    }

    const tags = [
      { property: 'og:title', content: title },
      { property: 'og:description', content: description },
      { property: 'og:url', content: pageUrl },
      { property: 'og:image', content: ogImageUrl },
      { property: 'og:type', content: 'website' },
      { property: 'twitter:card', content: 'summary_large_image' },
      { property: 'twitter:title', content: title },
      { property: 'twitter:description', content: description },
      { property: 'twitter:image', content: ogImageUrl },
    ];

    // Create a new response by transforming the original response
    const transformedResponse = new HTMLRewriter()
      .on('head', new MetaTagInjector(tags))
      .transform(response);
      
    return transformedResponse;
  }

  // If not rewriting (no bg/fg params, not GET, or not HTML), return the original response from next()
  return response; 
} 