export async function onRequest(context) {
  const { request, env, next } = context;
  const url = new URL(request.url);

  // Fetch the original response from the underlying asset or the next function in the chain
  const originalResponse = await next();

  // Only proceed if the response is HTML
  if (!originalResponse.headers.get("content-type")?.includes("text/html")) {
    return originalResponse; // Not HTML, so pass through untouched
  }

  // Check for dynamic OG parameters
  const bgParam = url.searchParams.get('bg');
  const fgParam = url.searchParams.get('fg');
  const isGetRequest = request.method === 'GET';

  let tagsToInject = [];
  let shouldRewrite = false;

  if (isGetRequest && bgParam && fgParam) {
    // Conditions met for dynamic OG tags
    shouldRewrite = true;
    const encodedBg = encodeURIComponent(bgParam);
    const encodedFg = encodeURIComponent(fgParam);
    const ogImageWorkerUrl = 'https://randoma11y-feed.adam-f8f.workers.dev';
    const ogImageUrl = `${ogImageWorkerUrl}/og-image.svg?bg=${encodedBg}&fg=${encodedFg}`;
    const pageUrl = url.toString();
    const dynamicTitle = `RandomA11y: ${bgParam} / ${fgParam}`;
    const dynamicDescription = `Explore this accessible color combination: ${bgParam} background with ${fgParam} text. Generated by RandomA11y.`;

    tagsToInject = [
      { property: 'og:title', content: dynamicTitle },
      { property: 'og:description', content: dynamicDescription },
      { property: 'og:url', content: pageUrl },
      { property: 'og:image', content: ogImageUrl },
      { property: 'og:image:width', content: '1200' },
      { property: 'og:image:height', content: '630' },
      { property: 'og:type', content: 'website' },
      { property: 'twitter:card', content: 'summary_large_image' },
      { property: 'twitter:title', content: dynamicTitle },
      { property: 'twitter:description', content: dynamicDescription },
      { property: 'twitter:image', content: ogImageUrl },
    ];
  } else {
    // No dynamic params, or not a GET request. 
    // We will rely on the static tags already in index.html.
    // However, HTMLRewriter will still run to ensure no duplicates if any somehow existed.
    // Or, you could choose to *not* run HTMLRewriter at all in this case if you are certain
    // your index.html is the sole source of truth for default tags and has no duplicates.
    // For safety, and to ensure any erroneous pre-existing tags are cleared if dynamic ones were *almost* applied,
    // we can run a cleaner that just removes our target tags, relying on index.html to provide them fresh.
    // A simpler approach: if not dynamic, don't rewrite. The static tags will be served.
    // Let's go with not rewriting if not dynamic, as it's cleaner.
    return originalResponse; // Serve the original HTML with its static tags.
  }

  // If we decided we should rewrite (i.e., for dynamic tags)
  if (shouldRewrite) {
    class MetaTagManager {
      constructor(tags) {
        this.tagsToSet = tags;
        this.seenProperties = new Set(); // To handle removing only what we intend to set
        this.tagsToSet.forEach(tag => this.seenProperties.add(tag.property));
      }

      element(element) {
        const property = element.getAttribute('property'); // For og:*
        const name = element.getAttribute('name'); // For twitter:*

        if ((property && this.seenProperties.has(property)) || 
            (name && this.seenProperties.has(name))) {
          element.remove();
        }
      }

      end(end) {
        let tagsHtml = '<!-- Dynamic OG Tags Injected by Pages Function -->\n';
        this.tagsToSet.forEach(tag => {
          const attributeType = tag.property.startsWith('twitter:') ? 'name' : 'property';
          const escapedContent = tag.content.replace(/"/g, '&quot;').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
          tagsHtml += `<meta ${attributeType}="${tag.property}" content="${escapedContent}" />\n`;
        });
        end.append(tagsHtml, { html: true });
      }
    }

    return new HTMLRewriter()
      .on('head', new MetaTagManager(tagsToInject))
      .transform(originalResponse);
  }

  // Fallback, should ideally be covered by the else in the dynamic check
  return originalResponse;
} 